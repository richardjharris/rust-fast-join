rjoin - rico's join
-------------------

Similar to unix join(1) or gjoin, with the following differences:

 - O(1) memory usage - don't allocate O(n) memory when joining
   files with a large number of matching rows

 - Cross-joins do not generate NxM output rows. There are not
   really supported. (Need to detect them at some point)

 - Join on multiple fields (-l 1,2 -r 1,2)

 - Slightly clearer options: -l/-r to specify join field(s), -L/-R
   to specify an inner join on the left or right side

 - --outer for outer joins (equivalent to -L -R)

 - -j for specifying the key field for both the left and right files
   simultaneously (equivalent to -l X -r X)

 - Supports several output formats:
   -o auto : uses first line to determine column count for each file;
             outputs key field(s) followed by all non-key fields of left,
             then right file. Consistent number of output columns
   
   -o gnudefault : GNU join default: key field, followed by all non-key
             fields of each file. Number of columns may change for each
             output line, depending on input.

   -o 0,1.1,1.2,2.1 : standard GNU join output format

   -o 0,1.1-10,2.2-5 : shorthand for column ranges (new)

 - --left-missing and -right-missing values allow custom placeholder values
   for missing left/right rows when performaing left or right outer joins.

    e.g. --left-missing '[New]' --right-missing '[Expired]'

   This differs from GNU join's -e option, which fills in both missing
   relationship data, and all blank columns in both input files.
 
 - Performance is roughly comparable with GNU join.
 
 - -t for custom input/output separator

 - --header to read header from input files, and include joined header
   in output.

Things to think about adding
----------------------------

 * -e EMPTY for replacing missing input fields (useful?)
 * -i ignorecase
 * -v to do a not-exists join
 * --check-order
 * Support for named fields in -o, -r/-l/-j

 Trailing newlines: GNU join behaviour is to consider a trailing newline to be
 a real field, with no columns. It outputs an empty line at the end! We do the
 same, except currently splitline will panic :P

 There are many panics, e.g. if the header column count doesn't match the
 next line (which is used for -o auto). Possibly -o auto could use the header
 line...

New design?
-----------

The use of structs to hold user arguments which get turned into runtime args
is a bit hacky. A builder pattern might work better...

 let r = RJoin::new( leftFile, rightFile );
 r.set_output(output);  # headers already read
 r.set_key(0, '1'); 

But delim/header have to be set for set_output to work properly... tricky

Divide args into: file reading (header, delim, filenames)
  and joining?
  and output?

  FileReader (x2) -> Joiner -> Output

For example

 let left = FileReader(filename, delim, header);
 let right = FileReader(filename, delim, header);
 let join = Joiner(left, right);
 join.set_all(0, true);
 join.set_missing(0, '[Expired]');
 join.set_keys(0, '1,2');
 let output = ColumnOutput(delim, '1.1,2.1', to_stdout);
 join.do_join(output);

This enforces the correct ordering. And no longer need to import a million
things. It's the object's responsibility to parse stuff. I suppose we could
parse stuff with the help of the left/right objects, same with set_keys.
